{"title":"Runtime(一) 介绍","date":"2019-04-28T05:34:21.000Z","slug":"iOS-runtime-node-1","comments":true,"tags":["Runtime"],"categories":["iOS"],"updated":"2019-07-10T03:35:32.000Z","content":"<h1 id=\"Runtime-介绍\">Runtime 介绍<a href=\"post/iOS-runtime-node-1#Runtime-介绍\"></a></h1><p>关于Runtime的官方文档在<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"介绍\">介绍<a href=\"post/iOS-runtime-node-1#介绍\"></a></h2><p>对于一个 iOS 开发者来说，基本上都会接触到Objective-c这门语言，而这门语言和其他大多数我们所熟知的语言有所不同，它是一门动态语言：动态类型、动态绑定、动态加载。它会将程序的一些决定工作从编译期推迟到运行期，由于这种运行时的特性，所以其不知需要依赖编译器，还需要依赖运行时环境，也就是Runtime.</p>\n<p>什么是Runtime ？ </p>\n<p>这个问题是在我们面试的时候常常被问到的问题，可能有些人会回答黑魔法、方法交换这些。也不能说不对，但是十分局限，应该用来回答什么是<code>runtime.h</code>而不应该回答什么是Runtime.</p>\n<p>Runtime其实不仅仅只是一些C语言的API，它是一套完整的面向对象的数据结构和一套由C、C++、汇编实现的API</p>\n<p>所以在我看来研究Runtime更重要的是要理解它整体的对象模型，而不是仅仅只学习一些API。</p>\n<p>而理解其中的数据结构，最快的途径莫过于去读它实现的源码，源码在<a href=\"https://opensource.apple.com/\" target=\"_blank\" rel=\"noopener\">官方开源</a>文件可以找到.</p>\n<p>现在最新的版本是<code>objc4-750.1</code></p>\n<p>根据苹果官方文档的描述，OC的运行时版本分为两个<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html#//apple_ref/doc/uid/TP40008048-CH106-SW2\" target=\"_blank\" rel=\"noopener\">Modern and Legacy</a>, 两者的区别在于<code>Legacy</code>在实例变量发生改变后，需要重新编译其继承的类, 而<code>Modern</code>在实例变量发生改变后不需要重新编译其继承的类。</p>\n<h2 id=\"与Runtime交互\">与Runtime交互<a href=\"post/iOS-runtime-node-1#与Runtime交互\"></a></h2><blockquote>\n<p>Objective-C programs interact with the runtime system at three distinct levels: through Objective-C source code; through methods defined in the NSObject class of the Foundation framework; and through direct calls to runtime functions.</p>\n</blockquote>\n<p>Runtime是一个共享动态库，与Runtime交互一般通过三种方式：</p>\n<ol>\n<li>Objective-C源代码，直接使用OC源码，底层会通过Runtime为其提供运行时支持，上层不用关心Runtime运行</li>\n<li><code>NSObject</code>方法</li>\n<li>Runtime方法</li>\n</ol>\n<p>注：静态库和动态库是相对编译期和运行期的，静态库会在程序编译时链接到目标代码中，程序运行时将不需要改静态库。动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，因为在程序运行期间还需要动态库的存在。</p>\n<ul>\n<li>动态库，多个应用程序共享内存中得同一份库文件</li>\n<li>而静态库也可以重用，但不是共享使用</li>\n</ul>\n<p>使用RunTime方法需要引入下面两个头文件，一些基础方法都定义在下面两个文件中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"对象模型\">对象模型<a href=\"post/iOS-runtime-node-1#对象模型\"></a></h2><p>OC中每一个对象、类其实都是一个结构体。</p>\n<p>下图表示了对象、类、元类之间的关系，以及类的继承关系。</p>\n<div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2019/04/28/EMrvOH.jpg\" alt=\"对象模型\" data-zoomable></p></div>\n<p>首先我们看一下OC中对于实例对象的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    isa_t isa;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每一个OC实例对象都有一个<code>isa_t</code>类型的结构体<code>isa</code>,然后再看一下<code>isa_t</code>结构体的定义</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> isa_t &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    uintptr_t bits;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>isa_t</code>结构体中有一个<code>Class</code>类型的指针<code>cls</code>和一个<code>uintptr_t</code>类型的<code>bits</code>，也可以简单理解为<code>isa_t</code>就是指明了一个类，也就是说每一个对象都有一个<code>isa</code>指针指向该对象的类。</p>\n<p>然后我们再看一下<code>Class</code>的定义</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>\n<p><code>Class</code>是<code>objc_class</code>的别名,那就直接看<code>objc_class</code>的定义</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class : objc_object &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Class ISA;</span></span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    cache_t cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    class_data_bits_t bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Class</code>中有一个Class类型的<code>superclass</code>，指向的是本类的父类。同时，每一个类都是继承<code>objc_object</code></p>\n<p>也就是说类其实也是一个对象，也包含一个<code>isa</code>指针，而类的<code>isa</code>指针其实是指向该类的元类的，而元类的<code>isa</code>指针指向的是根元类，根元类的<code>isa</code>指针是指向自己的，从而完成一个闭环。</p>\n<p>实例对象是不包含方法列表的。</p>\n<ul>\n<li>当我们对一个实例发送消息时（-方法），会在该 <code>instance</code> 对应的类的 方法列表里查找。</li>\n<li>当我们对一个类发送消息时（+方法），会在该类的 <code>MetaClass</code> 的 方法列表里查找。</li>\n</ul>\n<p>在对象的继承体系中，类和元类都有各自的继承体系，他们都有共同的根父类<code>NSObject</code>，而<code>NSObject</code>的父类指向的是<code>nil</code>。</p>\n","prev":{"title":"Runtime(二) 基础定义","slug":"iOS-runtime-node-2"},"next":{"title":"iOS 头像裁剪、图片裁剪、微信头像裁剪","slug":"iOS-edit-image"},"link":"https://vesincc.github.io/post/iOS-runtime-node-1/","toc":[{"title":"Runtime 介绍","id":"Runtime-介绍","index":"1","children":[{"title":"介绍","id":"介绍","index":"1.1"},{"title":"与Runtime交互","id":"与Runtime交互","index":"1.2"},{"title":"对象模型","id":"对象模型","index":"1.3"}]}],"reward":true,"copyright":{"custom":"本文遵守 CC BY-NC-ND 4.0 请保持转载后文章内容的完整，以及文章出处。本人保留所有版权相关权利。"}}