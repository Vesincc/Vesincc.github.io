{"title":"Runtime(四) OC的消息机制","date":"2019-05-09T01:22:41.000Z","slug":"iOS-runtime-node-4","comments":true,"tags":["Runtime"],"categories":["iOS"],"updated":"2019-07-10T03:35:32.000Z","content":"<p>OC的消息机制分为三个阶段</p>\n<ul>\n<li>消息发送</li>\n<li>动态方法解析</li>\n<li>消息转发 </li>\n</ul>\n<h2 id=\"消息\">消息<a href=\"post/iOS-runtime-node-4#消息\"></a></h2><h3 id=\"objc-msgSend\">objc_msgSend<a href=\"post/iOS-runtime-node-4#objc-msgSend\"></a></h3><p>OC中的方法调用是通过<code>Runtime</code>实现的，<code>Runtime</code>进行方法调用实际上是通过<code>objc_msgSend</code>来发送消息，消息直到运行时才绑定到方法的实现。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[receiver message];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(receiver, selector);</span><br><span class=\"line\"></span><br><span class=\"line\">objc_msgSend(receiver，selector，arg1，arg2，...);</span><br></pre></td></tr></table></figure>\n<p>编译器会用<code>objc_msgSend</code>来转换消息的表达式。<code>objc_msgSend</code>默认带有两个参数，第一个参数是消息的接收者，第二个参数是一个<code>SEL</code>的参数，在项目中经常会出现不同的类定义了相同的方法，那这样的方法所对应的<code>SEL</code>是同一个吗？</p>\n<p>其实之前介绍<code>SEL</code>的时候就提到过，<code>SEL</code>其实可以简单的理解为一个<code>name</code>，而不同的类中相同名字的<code>SEL</code>所对应的都是同一个对象，地址也是相通的，我们可以进行验证。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Test</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">TestM</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Test method -&gt; %p\"</span>, <span class=\"keyword\">@selector</span>(method));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TestM</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"TestM method -&gt; %p\"</span>, <span class=\"keyword\">@selector</span>(method));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这是输出</span></span><br><span class=\"line\"><span class=\"number\">2019</span><span class=\"number\">-05</span><span class=\"number\">-09</span> <span class=\"number\">13</span>:<span class=\"number\">50</span>:<span class=\"number\">16.740745</span>+<span class=\"number\">0800</span> Runtime[<span class=\"number\">1642</span>:<span class=\"number\">625520</span>] Test method -&gt; <span class=\"number\">0x109910e24</span></span><br><span class=\"line\"><span class=\"number\">2019</span><span class=\"number\">-05</span><span class=\"number\">-09</span> <span class=\"number\">13</span>:<span class=\"number\">50</span>:<span class=\"number\">16.740876</span>+<span class=\"number\">0800</span> Runtime[<span class=\"number\">1642</span>:<span class=\"number\">625520</span>] TestM method -&gt; <span class=\"number\">0x109910e24</span></span><br></pre></td></tr></table></figure>\n<p><code>Runtime</code>维护了一个<code>SEL</code>的表，这个表存储对应的<code>SEL</code>所有相同的<code>SEL</code>都会被记录为一个。在项目加载的时候，会将所有的方法都加载到这个表中，动态生成的方法也会被加载到表中。</p>\n<h3 id=\"使用隐藏参数\">使用隐藏参数<a href=\"post/iOS-runtime-node-4#使用隐藏参数\"></a></h3><p>当<code>objc_msgSend</code>找到方法的实现后，他会调用改方法，并传递消息中的所有参数，这些参数为每个方法提供调用方法所需的显式参数信息，除此之外还提供了两个隐藏参数，他们是编译器在编译的时候插入到代码中的，并未在定义方法的时候进行声明。</p>\n<p>虽然这两个参数在调用和实现方法中都没有明确声明，但是我们仍然可以使用它。</p>\n<ul>\n<li><code>self</code>：调用当前方法的对象</li>\n<li><code>_cmd</code>：当前被调用方法的<code>SEL</code></li>\n</ul>\n<p>这也是为什么我们可以在方法中没有声明<code>self</code>，但是却可以通过<code>self</code>获取到当前对象的原因。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_EXPORT <span class=\"keyword\">void</span></span><br><span class=\"line\">objc_msgSend(<span class=\"keyword\">void</span> <span class=\"comment\">/* id self, SEL op, ... */</span> )</span><br><span class=\"line\">    OBJC_AVAILABLE(<span class=\"number\">10.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">9.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)method &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"receiver -&gt; %@\"</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"SEL -&gt; %s\"</span>, _cmd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里是输出</span></span><br><span class=\"line\"><span class=\"number\">2019</span><span class=\"number\">-05</span><span class=\"number\">-09</span> <span class=\"number\">15</span>:<span class=\"number\">09</span>:<span class=\"number\">00.411530</span>+<span class=\"number\">0800</span> Runtime[<span class=\"number\">2265</span>:<span class=\"number\">822794</span>] receiver -&gt; &lt;Test: <span class=\"number\">0x600000accf50</span>&gt;</span><br><span class=\"line\"><span class=\"number\">2019</span><span class=\"number\">-05</span><span class=\"number\">-09</span> <span class=\"number\">15</span>:<span class=\"number\">09</span>:<span class=\"number\">00.411652</span>+<span class=\"number\">0800</span> Runtime[<span class=\"number\">2265</span>:<span class=\"number\">822794</span>] SEL -&gt; method</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取方法地址\">获取方法地址<a href=\"post/iOS-runtime-node-4#获取方法地址\"></a></h3><p>规避动态绑定的唯一方法是获取到方法的<code>IMP</code>并且像函数一样直接调用方法。这种情况适用于极少数情况下，一些特定的需要连续多次执行的方法，通过获取方法地址调用可以避免消息传递的资源开销。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (IMP)methodForSelector:(SEL)aSelector;</span><br><span class=\"line\">+ (IMP)instanceMethodForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>\n<p>在之前的基础定义已经有所介绍了。</p>\n<p>注意的是返回和参数都要进行强制类型转换，传递过程前两个参数是<code>self</code>，和<code>_cmd</code>。隐藏参数在方法进行函数调用时必须显式化。</p>\n<p>使用<code>methodForSelector</code>规避动态绑定可以节省大部分消息发送所需的时间，但是只适用于特定消息重复多次发送的情况下。</p>\n<h3 id=\"方法查找\">方法查找<a href=\"post/iOS-runtime-node-4#方法查找\"></a></h3><p>还记得<code>objc_class</code>结构体吗？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class : objc_object &#123;</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    cache_t cache;  --&gt; 方法缓存           </span><br><span class=\"line\">    class_data_bits_t bits;    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> cache_t &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> bucket_t *_buckets; <span class=\"comment\">// 散列表</span></span><br><span class=\"line\">    mask_t _mask; <span class=\"comment\">// 散列表长度-1</span></span><br><span class=\"line\">    mask_t _occupied; <span class=\"comment\">// 已经缓存的方法数量</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> bucket_t &#123;</span><br><span class=\"line\">    <span class=\"comment\">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span></span><br><span class=\"line\">    <span class=\"comment\">// SEL-first is better for armv7* and i386 and x86_64.</span></span><br><span class=\"line\"><span class=\"meta\">#if __arm64__</span></span><br><span class=\"line\">    MethodCacheIMP _imp; <span class=\"comment\">// IMP地址</span></span><br><span class=\"line\">    cache_key_t _key; <span class=\"comment\">// SEL作为key</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\">    cache_key_t _key;</span><br><span class=\"line\">    MethodCacheIMP _imp;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>buckets</code>散列表是一个数组，数组中的每个元素都是一个<code>bucket_t</code>，<code>bucket_t</code>以方法的<code>SEL</code>为<code>key</code>，<code>IMP</code>为值，对<code>Method</code>进行存储。<code>_mask</code>是散列表的长度-1，<code>_occupied</code>是已经缓存的方法数量。</p>\n<p>所以正常方法查找流程为</p>\n<ol>\n<li>对象通过<code>isa</code>找到该对象的类对象。</li>\n<li>在缓存中查找该方法，找到直接调用。</li>\n<li>缓存中没有找到就去类的<code>class_rw</code>的<code>methods</code>中找，如果找到了，调用并缓存该方法。</li>\n<li>如果<code>class_rw</code>中没有找到，通过<code>superclass</code>到父类中重复第2、3、4。</li>\n<li>如果在父类中找到了，会将该方法缓存到<strong>当前类</strong>的方法缓存列表中。</li>\n</ol>\n<h2 id=\"消息发送\">消息发送<a href=\"post/iOS-runtime-node-4#消息发送\"></a></h2><h4 id=\"父类逐级查找流程\">父类逐级查找流程<a href=\"post/iOS-runtime-node-4#父类逐级查找流程\"></a></h4><div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2019/05/10/ERTCkD.jpg\" alt data-zoomable></p></div>\n<h4 id=\"消息发送流程\">消息发送流程<a href=\"post/iOS-runtime-node-4#消息发送流程\"></a></h4><div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2019/05/10/ERoVdU.jpg\" alt data-zoomable></p></div>\n<h2 id=\"动态方法解析\">动态方法解析<a href=\"post/iOS-runtime-node-4#动态方法解析\"></a></h2><p>当一个方法在其所有父类当中查找后都没有命中，也就是在<code>cache</code>和其继承关系的<code>method list</code>中都没有找到对应的方法。这时会进入消息转发阶段，但是在进入消息转发阶段之前，<code>Runtime</code>会给一次机会动态添加方法的实现。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(<span class=\"number\">10.5</span>, <span class=\"number\">2.0</span>, <span class=\"number\">9.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>);</span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(<span class=\"number\">10.5</span>, <span class=\"number\">2.0</span>, <span class=\"number\">9.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>);</span><br></pre></td></tr></table></figure>\n<p>我们可以通过重写<code>NSObject</code>的<code>resolveClassMethod:</code>和<code>resolveInstanceMethod:</code>方法，动态添加未实现的方法。这两个方法都有一个<code>BOOL</code>返回值，返回<code>NO</code>则进入方法转发阶段。</p>\n<div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2019/05/10/ERbNHP.jpg\" alt data-zoomable></p></div>\n<h2 id=\"消息转发\">消息转发<a href=\"post/iOS-runtime-node-4#消息转发\"></a></h2><div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2019/05/13/E4BYDJ.jpg\" alt data-zoomable></p></div>\n","prev":{"title":"Runtime(五) 加载过程","slug":"iOS-runtime-node-5"},"next":{"title":"Runtime(三) 对象的初始化过程","slug":"iOS-runtime-node-3"},"link":"https://vesincc.github.io/post/iOS-runtime-node-4/","toc":[{"title":"消息","id":"消息","index":"1","children":[{"title":"objc_msgSend","id":"objc-msgSend","index":"1.1"},{"title":"使用隐藏参数","id":"使用隐藏参数","index":"1.2"},{"title":"获取方法地址","id":"获取方法地址","index":"1.3"},{"title":"方法查找","id":"方法查找","index":"1.4"}]},{"title":"消息发送","id":"消息发送","index":"2"},{"title":"动态方法解析","id":"动态方法解析","index":"3"},{"title":"消息转发","id":"消息转发","index":"4"}],"reward":true,"copyright":{"custom":"本文遵守 CC BY-NC-ND 4.0 请保持转载后文章内容的完整，以及文章出处。本人保留所有版权相关权利。"}}